#include "threads/interrupt.h"
#include <debug.h>
#include <inttypes.h>
#include <stdint.h>
#include <stdio.h>
#include "threads/flags.h"
#include "threads/intr-stubs.h"
#include "threads/io.h"
#include "threads/thread.h"
#include "threads/vaddr.h"
#include "devices/timer.h"
#ifdef USERPROG
#include "userprog/gdt.h"
#endif

// 可编程中断控制器
// 8259A PIC的主要作用是：
// 中断管理：8259A可以管理来自多个设备的中断请求，并将它们发送给CPU处理。
// 优先级处理：它能够对多个中断请求进行优先级排序，确保高优先级的中断请求得到优先处理。
// 中断屏蔽：可以屏蔽特定的中断请求，防止它们被处理。

/** Programmable Interrupt Controller (PIC) registers.
   A PC has two PICs, called the master and slave PICs, with the
   slave attached ("cascaded") to the master IRQ line 2. */
#define PIC0_CTRL	0x20    /**< Master PIC control register address. */
#define PIC0_DATA	0x21    /**< Master PIC data register address. */
#define PIC1_CTRL	0xa0    /**< Slave PIC control register address. */
#define PIC1_DATA	0xa1    /**< Slave PIC data register address. */

/** Number of x86 interrupts. */
#define INTR_CNT 256

/** The Interrupt Descriptor Table (IDT).  The format is fixed by
   the CPU.  See [IA32-v3a] sections 5.10 "Interrupt Descriptor
   Table (IDT)", 5.11 "IDT Descriptors", 5.12.1.2 "Flag Usage By
   Exception- or Interrupt-Handler Procedure". */
static uint64_t idt[INTR_CNT];

/** Interrupt handler functions for each interrupt. */
static intr_handler_func *intr_handlers[INTR_CNT];

/** Names for each interrupt, for debugging purposes. */
static const char *intr_names[INTR_CNT];

/** Number of unexpected interrupts for each vector.  An
   unexpected interrupt is one that has no registered handler. */
static unsigned int unexpected_cnt[INTR_CNT];

//
/** External interrupts are those generated by devices outside the
   CPU, such as the timer. [[[[[ External interrupts run with
   interrupts turned off, so they [[[ never nest ]]], nor are they ever
   pre-empted(被抢占). [[[ Handlers for external interrupts also may not
   sleep, ]]] although they may invoke intr_yield_on_return() to
   request that a new process be scheduled just before the
   interrupt returns. ]]]]] */
static bool in_external_intr;   /**< Are we processing an external interrupt? */
static bool yield_on_return;    /**< Should we yield on interrupt return? */

/** Programmable Interrupt Controller helpers. */
static void pic_init (void);
static void pic_end_of_interrupt (int irq);

/** Interrupt Descriptor Table helpers. */
static uint64_t make_intr_gate (void (*) (void), int dpl);
static uint64_t make_trap_gate (void (*) (void), int dpl);
static inline uint64_t make_idtr_operand (uint16_t limit, void *base);

/** Interrupt handlers. */
void intr_handler (struct intr_frame *args);
static void unexpected_interrupt (const struct intr_frame *);


// 通过内联汇编读取EFLAGS寄存器的值，检查中断标志位的状态
/** Returns the current interrupt status. */
enum intr_level
intr_get_level (void) 
{
  // 用于存储从EFLAGS寄存器中读取的标志值
  uint32_t flags;

  /* Push the flags register on the processor stack, then pop the
     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
     Interrupts". */
  asm volatile ("pushfl; popl %0" : "=g" (flags)); // =g 表示任意一个寄存器或内存位置来存储输出

  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
}

/** Enables or disables interrupts as specified by LEVEL and
   returns the previous interrupt status. */
enum intr_level
intr_set_level (enum intr_level level) 
{
  return level == INTR_ON ? intr_enable () : intr_disable ();
}

/** Enables interrupts and returns the previous interrupt status. */
enum intr_level
intr_enable (void) 
{
  enum intr_level old_level = intr_get_level ();
  // 不应该在外中断
  ASSERT (!intr_context ());

  /* Enable interrupts by setting the interrupt flag.

     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("sti"); // sti(Set Interrupt Flag), 用于设置CPU的中断标志位(IF，Interrupt Flag)

  return old_level;
}

// 任何同步问题都可以通过关闭中断解决, 关闭了中断, 就没有concurrency
// [[[ intr_disable并不关闭内中断 ]]], 因为内中断由CPU产生, 和CPU指令是同步的
// [[[ 尽量减少关闭中断时的代码, 否则会丢失timer ticks或者input events. ]]]
/** Disables interrupts and returns the previous interrupt status. */
enum intr_level
intr_disable (void) 
{
  enum intr_level old_level = intr_get_level ();

  /* Disable interrupts by clearing the interrupt flag.
     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("cli" : : : "memory");
  // asm("assembly code" : output operands : input operands : clobbered registers(破坏列表));

  return old_level;
}

/** Initializes the interrupt system. */
void
intr_init (void)
{
  uint64_t idtr_operand;
  int i;

  /* Initialize interrupt controller. */
  pic_init ();

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
    idt[i] = make_intr_gate (intr_stubs[i], 0);

  /* Load IDT register.
     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
  asm volatile ("lidt %0" : : "m" (idtr_operand)); // idtr_operand是输入

  // 这些是CPU固定的中断号?
  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
    intr_names[i] = "unknown";
  intr_names[0] = "#DE Divide Error";
  intr_names[1] = "#DB Debug Exception";
  intr_names[2] = "NMI Interrupt";
  intr_names[3] = "#BP Breakpoint Exception";
  intr_names[4] = "#OF Overflow Exception";
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
  intr_names[6] = "#UD Invalid Opcode Exception";
  intr_names[7] = "#NM Device Not Available Exception";
  intr_names[8] = "#DF Double Fault Exception";
  intr_names[9] = "Coprocessor Segment Overrun";
  intr_names[10] = "#TS Invalid TSS Exception";
  intr_names[11] = "#NP Segment Not Present";
  intr_names[12] = "#SS Stack Fault Exception";
  intr_names[13] = "#GP General Protection Exception";
  intr_names[14] = "#PF Page-Fault Exception";
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
  intr_names[17] = "#AC Alignment Check Exception";
  intr_names[18] = "#MC Machine-Check Exception";
  intr_names[19] = "#XF SIMD Floating-Point Exception";
}

/** Registers interrupt VEC_NO to invoke HANDLER with descriptor
   privilege level DPL.  Names the interrupt NAME for debugging
   purposes.  The interrupt handler will be invoked with
   interrupt status set to LEVEL. */
static void
register_handler (uint8_t vec_no, int dpl, enum intr_level level,
                  intr_handler_func *handler, const char *name)
{
  ASSERT (intr_handlers[vec_no] == NULL);
  if (level == INTR_ON)
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
  else
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
  intr_handlers[vec_no] = handler;
  intr_names[vec_no] = name;
}

// 在外中断handler中, 传递给handler的struct intr_frame没什么用, 因为不知道是哪个thread被中断了

// 一次只能处理一个外中断
// 内中断和外中断都不能在外中断handler中嵌套, 外中断时必须关闭中断, (TODO handler出现page fault怎么办? 关中断只是关外中断,内中断依然是和CPU同步的)

// 外中断handler不能sleep和yield, 所以不能调用lock_acquire(), thread_yield()等函数
// 在外中断上下文中sleep也会使被中断的线程sleep, 直到中断处理程序再次被调度并返回
// 这对于unlucky thread来说是不公平的,
// 并且如果handler正在等待sleeping thread to(release a lock),
// 则会发生死锁(因为外中断时关了中断,不能schedule到其它thread ?).

// 外中断处理程序独占机器并延迟所有其他活动, 应尽快完成

// 外中断由CPU之外的一对可编程中断控制器控制
// 当intr_init设置CPU的IDT时, 也会初始化PICs for interrupt handling
// PICs在外中断处理的最后必须被acknowledged, intr_handler -> pic_end_of_interrupt

// 在src/devices里面的文件中有注册
/** Registers external interrupt VEC_NO to invoke HANDLER, which
   is named NAME for debugging purposes.  The handler will
   execute with interrupts disabled. */
void
intr_register_ext (uint8_t vec_no, intr_handler_func *handler,
                   const char *name) 
{
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
  // The handler will run with interrupts disabled.
  register_handler (vec_no, 0, INTR_OFF, handler, name);
}

// 在内中断的handler中, 可以查看和修改传给handler的struct intr_frame,
// 对intr_frame的修改可以反映到被中断的线程,
// 例如Pintos系统调用通过修改保存到intr_frame的eax来返回值

// 内中断可能被其它kernel threads抢占,需要在共享资源上和其它线程同步
// TODO 哪些是共享资源?
// 内中断可以被递归调用,例如系统调用handler可能造成page fault
/** Registers internal interrupt VEC_NO to invoke HANDLER, which
   is named NAME for debugging purposes.  The interrupt handler
   will be invoked with interrupt status LEVEL.

   The handler will have descriptor privilege level DPL, meaning
   that it can be invoked intentionally when the processor is in
   the DPL or lower-numbered ring.  In practice, DPL==3 allows
   user mode to invoke the interrupts and DPL==0 prevents such
   invocation.  Faults and exceptions that occur in user mode
   still cause interrupts with DPL==0 to be invoked.  See
   [IA32-v3a] sections 4.5 "Privilege Levels" and 4.8.1.1
   "Accessing Nonconforming Code Segments" for further
   discussion. */
void
intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,
                   intr_handler_func *handler, const char *name)
{
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
  register_handler (vec_no, dpl, level, handler, name);
}

// 返回当前是否在处理外中断
/** Returns true during processing of an external interrupt
   and false at all other times. */
bool
intr_context (void) 
{
  return in_external_intr;
}

// thread_tick中会调用intr_yield_on_return,表示时间片到了,应该在中断结束后让出CPU
// When called in an interrupt context, causes thread_yield()
// to be called just before the interrupt returns.
// Used in the timer interrupt handler when a thread's time slice expires,
// to cause a new thread to be scheduled.
/** During processing of an external interrupt, directs the
   interrupt handler to yield to a new process just before
   returning from the interrupt.  May not be called at any other
   time. */
void
intr_yield_on_return (void) 
{
  ASSERT (intr_context ());
  yield_on_return = true;
}


// PICs传来的中断号0-15号会默认走到interrupt vectors 0...15,
// 这和CPU的traps and exceptions重叠了,所以把0-15映射到32-47
/** 8259A Programmable Interrupt Controller. */

/** Initializes the PICs.  Refer to [8259A] for details.

   By default, interrupts 0...15 delivered by the PICs will go to
   interrupt vectors 0...15.  Those vectors are also used for CPU
   traps and exceptions, so we reprogram the PICs so that
   interrupts 0...15 are delivered to interrupt vectors 32...47
   (0x20...0x2f) instead. */
static void
pic_init (void)
{
  // 这两行屏蔽了主PIC和从PIC的所有中断请求，确保在初始化过程中不会有中断发生。
  /* Mask all interrupts on both PICs. */
  outb (PIC0_DATA, 0xff);
  outb (PIC1_DATA, 0xff);

  /* Initialize master. */
  outb (PIC0_CTRL, 0x11); /**< ICW1: single mode, edge triggered, expect ICW4. */
  outb (PIC0_DATA, 0x20); /**< ICW2: line IR0...7 -> irq 0x20...0x27. */
  outb (PIC0_DATA, 0x04); /**< ICW3: slave PIC on line IR2. */
  outb (PIC0_DATA, 0x01); /**< ICW4: 8086 mode, normal EOI, non-buffered. */

  /* Initialize slave. */
  outb (PIC1_CTRL, 0x11); /**< ICW1: single mode, edge triggered, expect ICW4. */
  outb (PIC1_DATA, 0x28); /**< ICW2: line IR0...7 -> irq 0x28...0x2f. */
  outb (PIC1_DATA, 0x02); /**< ICW3: slave ID is 2. */
  outb (PIC1_DATA, 0x01); /**< ICW4: 8086 mode, normal EOI, non-buffered. */

  /* Unmask all interrupts. */
  outb (PIC0_DATA, 0x00);
  outb (PIC1_DATA, 0x00);
}

/** Sends an [[[ end-of-interrupt signal ]]] to the PIC for the given IRQ.
   [[[ If we don't acknowledge the IRQ, it will never be delivered to
   us again, ]]] so this is important.  */
static void
pic_end_of_interrupt (int irq) 
{
  ASSERT (irq >= 0x20 && irq < 0x30);

  /* Acknowledge master PIC. */
  outb (0x20, 0x20);

  /* Acknowledge slave PIC if this is a slave interrupt. */
  if (irq >= 0x28)
    outb (0xa0, 0x20);
}


// 描述符权限级别（Descriptor Privilege Level，DPL）
// DPL: 描述符权限级别, 范围为0到3, 用于控制哪些权限级别(ring)可以调用该门.
// 权限级别0是最高权限级别, 通常用于内核态. 权限级别3是最低权限级别, 通常用于用户态.
// DPL==3: 允许用户态代码调用该门, 即用户态可以显式调用该门.
// DPL==0: 禁止用户态代码调用该门, 仅内核态代码可以显式调用.
// 即便是DPL为0的门描述符, 用户态发生的故障和异常仍然会触发这些门描述符的调用.
/** Creates an gate that invokes FUNCTION.

   The gate has descriptor privilege level DPL, meaning that it
   can be invoked intentionally(故意) when the processor is in the DPL
   or lower-numbered ring.  In practice, DPL==3 allows user mode
   to call into the gate and DPL==0 prevents such calls.  Faults
   and exceptions that occur in user mode still cause gates with
   DPL==0 to be invoked.  See [IA32-v3a] sections 4.5 "Privilege
   Levels" and 4.8.1.1 "Accessing Nonconforming Code Segments"
   for further discussion.

   TYPE must be either 14 (for an interrupt gate) or 15 (for a
   trap gate).  The difference is that entering an interrupt gate
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
  uint32_t e0, e1;

  ASSERT (function != NULL);
  ASSERT (dpl >= 0 && dpl <= 3);
  ASSERT (type >= 0 && type <= 15);

  e0 = (((uint32_t) function & 0xffff)     /**< Offset 15:0. */
        | (SEL_KCSEG << 16));              /**< Target code segment. */

  e1 = (((uint32_t) function & 0xffff0000) /**< Offset 31:16. */
        | (1 << 15)                        /**< Present. */
        | ((uint32_t) dpl << 13)           /**< Descriptor privilege level. */
        | (0 << 12)                        /**< System. */
        | ((uint32_t) type << 8));         /**< Gate type. */

  return e0 | ((uint64_t) e1 << 32);
}

/** Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 14);
}

/** Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 15);
}

/** Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
  return limit | ((uint64_t) (uint32_t) base << 16);
}

/* Returns true if this trap to the OS was from userspace */
#ifdef USERPROG
static inline bool is_trap_from_userspace(struct intr_frame* frame) {
  return (frame->cs == SEL_UCSEG) && (frame->ss == SEL_UDSEG);
}
#endif

/** Interrupt handlers. */

// intr_handler被intr-stubs.S中的interrupt stubs调用
/** [[[ Handler for all interrupts, faults, and exceptions. ]]]  This
   function is called by the assembly language interrupt stubs in
   intr-stubs.S. [[[ FRAME describes the interrupt and the
   interrupted thread's registers. ]]] */
void
intr_handler (struct intr_frame *frame) 
{
  bool external;
  intr_handler_func *handler;

  /* External interrupts are special.
   * TODO 为什么一次只能处理一个外中断
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     [[[ An external interrupt handler cannot sleep. TODO 为什么?? 大不了不执行指令不行吗 ]]] */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
  if (external) 
    {
      // TODO 在哪关的中断? 应该是CPU自己关的?
      // intr_register_int: Specifying INTR_OFF will cause the CPU to
      // disable external interrupts when it invokes the interrupt handler.
      ASSERT (intr_get_level () == INTR_OFF);
      // 返回当前是否在处理外中断
      ASSERT (!intr_context ());

      in_external_intr = true;
      // Should we yield on interrupt return?
      yield_on_return = false;
    }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
  if (handler != NULL)
    handler (frame);
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
    {
      /* There is no handler, but this interrupt can trigger
         spuriously due to a hardware fault or hardware race
         condition.  Ignore it. */
    }
  else
    unexpected_interrupt (frame);

  /* Complete the processing of an external interrupt. */
  if (external) 
    {
      ASSERT (intr_get_level () == INTR_OFF);
      ASSERT (intr_context ());

      in_external_intr = false;
      // Acknowledge interrupt
      pic_end_of_interrupt (frame->vec_no);

      // 前面不是设置了 yield_on_return = false; 吗
      // handler(如果是thread_tick)中会设置调用intr_yield_on_return设置yield_on_return
      if (yield_on_return)
        thread_yield (); 
    }
}

/** Handles an unexpected interrupt with interrupt frame F.  An
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];

  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
    printf ("Unexpected interrupt %#04x (%s)\n",
    f->vec_no, intr_names[f->vec_no]);
}

/** Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
  uint32_t cr2;

  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));

  printf ("Interrupt %#04x (%s) at eip=%p\n",
          f->vec_no, intr_names[f->vec_no], f->eip);
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
          f->cs, f->ds, f->es, f->ss);
}

/** Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
  return intr_names[vec];
}
